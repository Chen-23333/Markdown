# Cache

## 缓存架构设计

缓存一般使用内存来进行存储，性能会远优于从硬盘进行读写，所以天然具备高性能和高并发两大优势，一般常用于加速读写和降低存储层负载。

在设计缓存方案时，同样需要从高性能、高并发、高可用三个角度进行衡量，结合业务特性进行设计，并在此基础上额外考虑成本问题。

针对于各项衡量指标，其主要影响因素如下所示：

<table>
    <tr>
        <th></th>
        <th>衡量指标</th>
        <th>影响因素</th>
    </tr>
    <tr>
        <th rowspan="6">高性能</th>
        <td rowspan="3">读写性能</td>
        <td>内存读取速率</td>
    </tr>
    <tr>
        <td>数据结构</td>
    </tr>
    <tr>
        <td>序列化/反序列化开销</td>
    </tr>
    <tr>
        <td rowspan="2">命中率</td>
        <td>缓存大小</td>
    </tr>
    <tr>
        <td>淘汰策略</td>
    </tr>
    <tr>
        <td>网络延迟</td>
        <td>集群分布</td>
    </tr>
    <tr>
        <th rowspan="6">高并发</th>
        <td rowspan="3">一致性</td>
        <td>缓存一致性协议</td>
    </tr>
    <tr>
        <td>缓存策略</td>
    </tr>
    <tr>
        <td>主从同步</td>
    </tr>
    <tr>
        <td rowspan="2">负载均衡</td>
        <td>分布式架构</td>
    </tr>
    <tr>
        <td>负载均衡算法</td>
    </tr>
    <tr>
        <td>并发控制</td>
        <td>事务</td>
    </tr>
    <tr>
        <th rowspan="5">高可用</th>
        <td rowspan="2">容错机制</td>
        <td>数据备份</td>
    </tr>
    <tr>
        <td>数据持久化</td>
    </tr>
    <tr>
        <td rowspan="2">故障转移</td>
        <td>主从架构</td>
    </tr>
    <tr>
        <td>哨兵机制</td>
    </tr>
    <tr>
        <td>监控</td>
        <td>实时监控与报警</td>
    </tr>
</table>

## 缓存策略

缓存策略，也被称作缓存模式，即 Cache Pattern，定义了应用层、缓存层、存储层之间的交互方式，包括读写顺序与更新策略。

### Cache Aside

Cache Aside 是最常用的一种缓存策略，其主要流程如下

- 读取缓存命中：

  - 返回缓存中的数据

- 读取缓存层未命中：

  - 从存储层中读取数据并返回
  - 将数据写入缓存

- 更新数据：

  - 更新存储数据
  - 删除缓存数据

### Read Through

### Write Through

### Write Around

### Write Back/Behind

## 常见问题

### 缓存雪崩

大量数据同时过期或者缓存层服务故障，从而导致大量请求直接访问存储层，进而导致系统崩溃。

#### 打散过期时间

在设置数据的过期时间时，加上随机数，避免同时过期。

#### 互斥锁

在处理业务请求时，如果缓存未命中，则添加互斥锁，仅由该次请求去读取存储层，重新构建缓存。在缓存更新成功后，释放互斥锁，需要注意互斥锁的超时时间。

对于未获取到锁的请求，可以考虑等待锁释放后，重新读取缓存，或是直接返回默认值。

#### 永不过期

不再设置缓存的有效期，由专门的后台线程，通过定时任务等方式处理更新逻辑。

对于由淘汰策略等情况导致的缓存失效，一种方式是由后台线程轮询检查缓存是否有效，另一种方式是业务线程发现缓存失效后，通过消息队列通知后台线程触发更新逻辑。

#### 缓存降级

一般情况下，当缓存失效时，请求会继续访问源数据，当流量较大时，会导致下游服务异常并引起雪崩问题。

此时可通过动态配置，例如在流量远大于缓存或存储层的吞吐量时，如果缓存失效，则直接返回默认值，或者缓存一个默认值，保护下游服务。对于后者，需要重点考虑空数据的资源占用问题，以及缓存与存储层的数据不一致的问题。

上述提到的“互斥锁”与“永不过期”两种方案中，对于缓存失效时的处理方案，也是缓存降级方案的一种体现。

#### 服务熔断或限流

缓存中间件的性能会远远高于存储层，当大量请求击穿缓存，去请求存储层时，极大概率存储层服务是无法承受的，并有可能会进一步影响其他上游服务。所以当雪崩发生时，最有效的方案是服务的限流和熔断。

对于限流来说，需要综合存储层可以承受的最大 QPS 来判断限流值，避免本服务的存储层出现问题，也避免其他依赖该存储层的服务出现问题。常见的限流算法有令牌桶算法和漏桶算法等。

对于熔断来说，当下游服务（包括本服务访问的缓存层服务、存储层服务）出现问题时，相关异常错误率会飙升，此时可以在服务内触发熔断，丢弃部分对于下游的请求，缓解下游压力。

#### 提高服务可用性

多集群、多机房。

### 缓存击穿

缓存中的所有数据，仍然符合二八法则，80% 的请求访问集中在其中 20% 的数据，这部分数据也可被称作热点数据。

当热点数据过期时，或者缓存中未缓存热点数据，此时仍会有大量请求直接访问存储层。

#### 互斥锁、永不过期、缓存降级

缓存穿透也可看作是缓存雪崩的某种特殊情况，仍然可以使用“互斥锁”、“永不过期”、“缓存降级”来进行防护。

#### 预热数据

对于已知的热数据新上线的情况，例如每天轮换的首页资源，可以在系统上线前，提前对相关数据进行预热，加载进缓存中。避免系统冷启动时，大量热点数据缓存未命中的情况。

### 缓存穿透

用户想要访问的数据，既不存在于缓存中，也不存在于存储层中，此时同样会导致大量请求直接访问存储层。

这种情况一般主要有两个原因导致，存储层数据丢失，例如误操作导致删库，或者请求参数异常，例如黑灰产恶意攻击、上游链路出现 bug 等。

#### 缓存降级

存储层本身不存在数据，所以缓存处直接处理，返回默认值或存储默认值即可，没有必要继续访问存储层。

#### 布隆过滤器

在访问缓存或是访问存储层之前，将存在的 key 值用布隆过滤器提前存储，用于拦截大部分 key 不存在的情况。

在引入布隆过滤器后，需要额外考虑新增 key 值的同步问题，避免布隆过滤器与缓存或是与存储层不一致的情况，所以适用于数据相对固定的场景。

### 差异点

缓存雪崩、缓存击穿、缓存穿透，三种问题最终的表现都比较一致，大量请求通过缓存后，继续访问存储层，导致下游存储层服务异常，但是导致问题的原因略有不同：

- 缓存雪崩：由于大量 key 值同时过期，或是缓存服务异常，导致服务整体可用性下降，侧重点在于整体

  - 首要考虑的是避免问题，通过“打散过期时间”来避免前者，通过“提高服务可用性”来避免后者
  - 其次要考虑单个 key 维度的解决方案，通过“互斥锁”、“永不过期”、“缓存降级”的方式，减小下游服务的压力
  - 最后要考虑整体服务的解决方案，通过“服务熔断或限流”，缓解问题

- 缓存击穿：由于热点数据缓存未命中导致，与缓存雪崩中大量 key 值同时过期较为类似，侧重点在于部分热点数据

  - 首要考虑避免问题，通过“预热数据”，避免系统冷启动时数据不存在的情况
  - 然后是热 key 过期问题，通过“互斥锁”、“永不过期”、“缓存降级”的方式进行缓解

- 缓存穿透：由于存储层本身不存在相关数据，缓存不可用导致，侧重点在于无法构建缓存

  - 首要考虑避免问题，通过“布隆过滤器”提前进行判断，避免访问缓存服务、存储层服务
  - 然后是解决问题，通过“缓存降级”的方式，将问题留在缓存层，避免存储层服务异常

即：

<table>
    <tr>
        <th>异常问题</th>
        <th>产生原因</th>
        <th>解决方案</th>
    </tr>
    <tr>
        <th rowspan="4">缓存雪崩</th>
        <td rowspan="2">大量 key 同时过期</td>
        <td>避免问题：打散过期时间</td>
    </tr>
    <tr>
        <td>解决问题：互斥锁、永不过期、缓存降级</td>
    </tr>
    <tr>
        <td rowspan="2">缓存服务异常</td>
        <td>避免问题：提高服务可用性</td>
    </tr>
    <tr>
        <td>解决问题：服务限流或熔断</td>
    </tr>
    <tr>
        <th rowspan="2">缓存击穿</th>
        <td rowspan="2">热点数据未命中</td>
        <td>避免问题：预热数据</td>
    </tr>
    <tr>
        <td>解决问题：互斥锁、永不过期、缓存降级</td>
    </tr>
    <tr>
        <th rowspan="2">缓存穿透</th>
        <td rowspan="2">存储层不存在相关数据</td>
        <td>避免问题：布隆过滤器</td>
    </tr>
    <tr>
        <td>解决问题：缓存降级</td>
    </tr>
</table>

## Web 系统缓存层级

- 客户端/前端缓存
- 负载均衡缓存
- CDN 缓存
- 服务端本地缓存
- 分布式缓存（Redis）
- 存储层缓存（数据库缓存）
