# GC

## 机制介绍

垃圾回收（[Garbage Collection](https://en.wikipedia.org/wiki/Garbage_collection_(computer_science))）是一种自动内存管理机制，定期从根对象（主要指全局变量、寄存器、栈）开始，遍历所有内存空间，找到所有不存在引用关系的对象，最终回收这些对象占用的内存空间。GC 主要是清理堆中的对象，栈中的变量因为栈本身后进先出的特点，其内存管理较为简单，不需要较为复杂的 GC 机制。

GC 能够帮助开发者自动的将无用的数据所占内存还给操作系统，减少了一定的开发成本，许多编程语言都采用了这一机制，例如 GO，Java 等。但是 GC 会引入额外的耗时问题，在扫描内存期间，需要暂停整个程序（Stop the world），存在一定的性能问题。

除此以外，还有一种被称作引用计数（[Automatic Reference Counting](https://en.wikipedia.org/wiki/Automatic_Reference_Counting)）的自动内存管理机制，为所有创建的对象分配一个计数器，当该对象被其他对象引用时计数加一，解除引用时计数减一，并定期回收所有计数为零的对象所占用的内存空间。

ARC 不会导致明显的卡顿问题，Objective-C、Python 等语言使用这种方式进行内存管理。但是会由于代码导致循环引用，两个或多个对象的计数器永远不会归零。对于这种场景，编程语言会通过 weak 关键字来声明弱引用，破坏循环，但是仍会因为代码问题，引发内存泄漏

与自动内存管理机制相对应的，是手动内存管理机制，例如在 C/C++ 中，需要开发者手动申请和释放内存空间，在性能上有较大优势，但是手动管理也最容易出现内存泄漏问题。另外，这些编程语言中，也会有三方库提供了 GC 的实现。

## 回收算法

GC 根据其回收算法不同，也有一些差异：

- 标记 - 清除：暂停程序中的所有线程，由 GC 线程从根对象开始，找到并标记堆中所有存活的对象，之后遍历堆中所有对象，回收所有未被标记到的对象，释放所占用的内存，最后恢复其他线程的运行
- 标记 - 压缩：流程与“标记-清除”类似，但会将被保留的对象迁移至连续的内存空间中，避免内存的碎片化
- 复制：将内存空间分为两部分，程序运行中的内存分配仅在其中一个半区进行，触发 GC 时，将保留的对象迁移至另外一个半区，然后回收当前半区的数据，以此循环
- 增量式：将内存空间分为若干区，每次只对某一区进行 GC
- 分代：将内存空间划分为年轻代与老年代，内存分配在年轻代进行，每次 GC 后会将保留的对象的寿命加一，达到阈值后迁移至老年代。针对不同区块，执行不同的 GC 策略。年轻代的对象生命周期较短，GC 较为频繁，老年代的对象生命周期较长，GC 的频率较低。某些场景下还会有不进行 GC 的永久代，用于存储数据常量等。

Golang 中的 GC 采用了“标记 - 清除”的方案，并在此基础了做了较多的优化。

## 三色标记
