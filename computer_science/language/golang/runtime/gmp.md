# GMP

## 进程 & 线程 & 协程

### 进程 与 线程

进程可以理解为计算机在内存中执行的程序，是资源分配的基本单位，线程可以理解为进程中具体的执行流程，是 CPU 调度的基本单位。

在多线程的场景下，各线程会共享部分进程中的资源，单个线程仅有少部分独有的数据，包括栈、寄存器等。

在做调度时，线程仅保存独有数据，对于虚拟内存等共享数据，可以不做切换，所以其上下文切换的开销远小于进程。

### 线程实现方式

线程一般根据其实现方式，分为用户线程、内核线程和轻量级进程三种。

用户线程是基于用户态的线程管理库实现的，可以看作用户线程与内核线程是 `N:1` 的关系。线程控制块也在线程库中实现，与内核是隔离的，线程的创建、调度、终止等，均是由线程库来完成，不依赖操作系统。但是另一方面，对于内核来说，仅能感知到进程本身，所以无法对线程进行调度与管理，所以其本质上还是进程，并不能完美符合线程的定义。

内核线程存在于内核空间，可以看作用户线程与内核线程是 `1:1` 的关系。线程控制块也存在放内核空间，由操作系统直接负责，实现了“线程是 CPU 调度的基本单位”，可以充分发挥多核 CPU 的能力。但是线程的创建、调度、终止等管理操作以及上下文信息的维护，均需要在内核进行处理，系统开销大。

轻量级进程（[Light-weight proces](https://en.wikipedia.org/wiki/Light-weight_process)）是一种特殊的进程，其在单个内核线程之上的用户空间中运行，并与进程中的其他轻量级进程共享地址空间与系统资源。对于不支持线程的操作系统来说，可以通过这种方案，对现有的进程做修改，最终实现内核线程的效果。

轻量级进程与内核线程是一比一的关系，在轻量级进程之上，仍然可以使用用户线程，所以可以实现用户线程与内核线程，`N:1`、`1:1`、`M:N` 三种比例模型。在 `M:N` 的场景下，CPU 直接调度轻量级进程，而大部分用户线程的切换也均发生在用户空间，综合了 `N:1`、`1:1` 两种比例模型的优点。

此外，轻量级进程也揭露了线程与进程的本质，我们要关注的，并非是严格区分进程与线程这两种结构。而是要区分资源占用，从实质上讲，他们均是程序执行所需的信息的集合，对于线程来说，他仅有执行调度的最小信息，例如寄存器状态，而其他必要信息，例如虚拟内存地址空间，全部来源于进程本身，在线程间共享。

### 协程

操作系统中的任务处理，可以分为协作式与抢占式。

- 协作式多任务处理
  - 要求每一个任务在恰当的时间，定期放弃执行，并由系统将资源交给其他任务执行
  - 任务在执行时不受调度影响，不会被中断，完全交由任务自己控制
  - 但是同样，如果任务的设计存在缺陷，在阻塞时也不释放资源，或是本身出现问题导致无法释放资源，操作系统也没有办法进行干预，会影响整个系统

- 抢占式多任务处理
  - 指任务完全交由操作系统进行调度，按照任务的优先级、任务的状态等因素，分配或收回资源
  - 这种情况下，即使任务执行存在问题，系统会按照调度算法，将资源交由其他任务，确保其他任务正常执行
  - 但是相对应的，抢占式的调度方案，调度的时机较为频繁，没有办法完美满足各个任务的资源需求。
  - 为了准确地进行上下文切换，需要额外的维护成本与调度时的资源消耗，在各任务间，也需要通过其他方式，例如锁、信号量等，保障并发安全

协程是以协作式进行多任务处理的一种实现方案，可以在执行时，通过 `yield` 调用其他协程，使自己被挂起，当下次被调用时，从上次 `yield` 执行的地方恢复，继续执行。普通的函数也可以看作是没有执行 `yield` 逻辑的协程。根据具体的实现方式，可分为有栈协程与无栈协程两种。

有栈协程是协程需要额外保存当前的上下文信息，包括函数调用栈及寄存器等信息，在协程间调度时，通过存储的上下文信息进行恢复。这种情况其实也就是所谓的用户线程。Golang 中的 Goroutine 实现的就是有栈协程。

无栈协程在调度时，不保存调用栈等相关信息，完全通过一些状态位来控制函数流程，完全避免了上下文切换，拥有更高的性能。例如使用 `switch-case` 实现，通过静态变量，控制每次所执行的代码块。JS 中的 async/await 实现的就是无栈协程。

```c
int function(void) {
    static int i, state = 0;
    switch (state) {
        case 0: // 函数开始执行
            print("First");
            state = 1;
            return state; // yield
        case 1:
            print("Second");
            state = 0;
            return state; // yield
    }
}
```

## Goroutine

## 参考

- <https://xiaolincoding.com/os/4_process/process_base.html#%E8%BF%9B%E7%A8%8B>
- <https://en.wikipedia.org/wiki/Light-weight_process>
- <https://naoffer.com/article/detail/2837>
- <https://mthli.xyz/stackful-stackless/>
- <https://www.chiark.greenend.org.uk/~sgtatham/coroutines.html>
